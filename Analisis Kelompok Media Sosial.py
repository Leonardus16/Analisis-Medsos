# -*- coding: utf-8 -*-
"""PengorbananAirMata_dan_Darah.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_E6vXegLqnz_WlJ7G-UT32vxIAfRxrWM
"""

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import warnings
import seaborn as sns

warnings.filterwarnings("ignore")

df = pd.read_csv("PemilukanYAY.csv", encoding = 'latin1')
df.head()

df['total_interaction'] = df['retweet_count'] + df['favorite_count']
df = df[['full_text', 'username', 'total_interaction']].sort_values(by='total_interaction', ascending=False)
df.head()

df['mention'] = df['full_text'].str.findall(r'@.*?(?=\s|$)')
df.head()

df.drop(['full_text'], inplace=True, axis=1)
df.head()

# Explode mention column
df = df.explode('mention')
df.info()

# Lower case all word in mention column
df['mention'] = df['mention'].str.lower()
df.head()

# Delete @ on every word in mention column
df['mention'] = df['mention'].str.replace('@', '')
df.head()

df.dropna(inplace=True)
df = df[df['mention'] != '']
df.info()

df.head()

# Drop total interaction
df.drop(['total_interaction'], inplace=True, axis=1)
df.drop_duplicates(inplace=True)
df.head()

# Drop column when username = mention
df = df[df['username'] != df['mention']]
df.info()

G = nx.from_pandas_edgelist(df, source='username', target='mention', create_using=nx.Graph())
print(str(G))

def initial_graph(G):
    degree = dict(G.degree())
    top_nodes = sorted(degree, key=degree.get, reverse=True)[:7]

    plt.figure(figsize=(13, 13))
    nx.draw_networkx(
        G,
        with_labels=True,
        labels={node: node if node in top_nodes else "" for node in G.nodes()},
        node_color='orange',
        edge_color='grey',
        linewidths=1,
        font_size=10,
        node_size=[v * 30 for v in dict(G.degree()).values()],
        pos=nx.fruchterman_reingold_layout(G)
    )
    plt.show()

initial_graph(G)

def filtered_connected_graph(G, min_com):
    centers = {}
    communities = {}
    G_main = G.copy()
    min_nb = min_com

    communities_generator = nx.algorithms.community.girvan_newman(G_main)
    top_level_communities = next(communities_generator)

    filter_com = [c for c in top_level_communities if len(c) > min_com]

    G_main = G_main.copy()

    nodes_to_remove = set(G_main.nodes) - set(node for community in filter_com for node in community)
    G_main.remove_nodes_from(nodes_to_remove)

    for i, community in enumerate(filter_com):
        subgraph = G_main.subgraph(community)
        center_node = max(subgraph.degree, key=lambda x: x[1])[0]
        centers[i] = center_node
        communities[i] = community

    degree = dict(G_main.degree())
    top_nodes = sorted(degree, key=degree.get, reverse=True)[:7]

    plt.figure(figsize=(13, 13))
    nx.draw_networkx(
        G_main,
        with_labels=True,
        labels={node: node if node in top_nodes else "" for node in G_main.nodes()},
        node_color='orange',
        edge_color='grey',
        linewidths=1,
        font_size=10,
        node_size=[v * 30 for v in dict(G_main.degree()).values()],
        pos=nx.fruchterman_reingold_layout(G_main)
    )

    plt.show()
    return G_main

G_main = filtered_connected_graph(G, 10)

print(str(G_main))

def girvan_newman(G):
    def most_valuable_edge(graph):
        centrality = nx.edge_betweenness_centrality(graph, weight='weight')
        return max(centrality, key=centrality.get)

    def without_most_central_edges(graph, most_valuable_edge_func):
        original_num_components = nx.number_connected_components(graph)
        num_new_components = original_num_components

        while num_new_components <= original_num_components:
            edge = most_valuable_edge_func(graph)
            graph.remove_edge(*edge)
            new_components = tuple(nx.connected_components(graph))
            num_new_components = len(new_components)
        return new_components

    if G.number_of_edges() == 0:
        return tuple(nx.connected_components(G))

    g = G.copy().to_undirected()
    g.remove_edges_from(nx.selfloop_edges(g))

    community = []
    modularities = []

    i = 0
    while g.number_of_edges() > 0:
        communities = without_most_central_edges(g, most_valuable_edge)
        modularity = nx.algorithms.community.modularity(G, communities)
        community.append(communities)
        modularities.append(modularity)

        print(f"Count of Community: {len(communities)}, Modularity: {modularity}")

        i += 1
        if len(modularities) > 10 and all(modularities[-i] < modularities[-10] for i in range(2, 10)):
            break

    return community, modularities

community, modularity = girvan_newman(G_main)

plt.figure(figsize=(12, 5))
plt.plot(range(2, len(modularity) + 2), modularity, marker='o')
for i, txt in enumerate(modularity):
    plt.annotate(round(txt, 3), (i+2, modularity[i]))
plt.xlabel("Number of Community")
plt.ylabel("Modularity")
plt.title("Modularity Over Number of Community")
plt.grid()
plt.show()

def visualize_gn(G, target_com):
    communities_generator = nx.algorithms.community.centrality.girvan_newman(G)

    target_num_communities = target_com

    node_groups = []
    color_map = []
    centers = {}
    labels = {}

    for i in range(target_num_communities):
        next(communities_generator)

    for com in next(communities_generator):
        node_groups.append(list(com))

    for node in G:
        for i in range(len(node_groups)):
            if node in node_groups[i]:
                color_map.append(i)

    for i, com in enumerate(node_groups):
        center = max(com, key=G.degree)
        centers[center] = node_groups[i]
        labels[center] = center

    plt.figure(figsize=(14, 14))
    nx.draw_networkx(
        G,
        labels=labels,
        with_labels=True,
        node_color=color_map,
        cmap=plt.cm.rainbow,
        edge_color='grey',
        linewidths=1,
        font_size=12,
        node_size=[v * 30 for v in dict(G.degree()).values()],
        pos=nx.fruchterman_reingold_layout(G)
    )

    plt.title(f"Community Detection - {len(node_groups)} communities\nModularity: {nx.algorithms.community.modularity(G, node_groups)}")
    plt.show()

    return centers

max_index_mod = modularity.index(max(modularity))
centers = visualize_gn(G_main, max_index_mod)

pd.DataFrame({
    'Center': list(centers.keys()),
    'Community': list(centers.values())
})